package _05_03_type_erasure_and_bridge_methods;

import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

/*
Type Erasure & Bridge Methods (Java generics runtime model)

Summary
- Java generics are a compile-time feature implemented via type erasure.
- After compilation:
  1) All type parameters are replaced with their erasure:
     - Unbounded T -> Object
     - Bounded T extends Upper & Other -> Upper (the first bound)
  2) Casts are inserted where necessary when reading generic values.
  3) Bridge methods are generated to preserve polymorphism and binary compatibility.

Key consequences
- No runtime type for type arguments: List<String> and List<Integer> have the same runtime class.
- Non-reifiable types (like List<String>) cannot be used in instanceof or array creation.
- Overloads that differ only by type parameters conflict after erasure.
- Raw types bypass compile-time checks and can cause heap pollution, yielding runtime ClassCastException.

Bridge methods: what/why/when
- Synthetic methods generated by the compiler (Method.isBridge() == true).
- They adapt method signatures that changed due to erasure so that overriding/implementing relationships remain valid at runtime.
- Typical scenarios:
  - Implementing a generic interface with a concrete type:
      interface Processor<T> { T process(T t); }
      class StringProcessor implements Processor<String> { String process(String s) { ... } }
    Compiler adds: Object process(Object) [bridge] -> delegates to process(String).
  - Subclass binds a superclassâ€™s type parameter and overrides:
      class Parent<T> { T get(); void set(T t); }
      class Child extends Parent<String> { String get(); void set(String s); }
    Compiler adds: Object get() [bridge], void set(Object) [bridge].
  - Covariant returns and methods like Comparable<T>#compareTo(T):
      class Person implements Comparable<Person> { int compareTo(Person p) { ... } }
    Compiler adds: int compareTo(Object) [bridge].

Common compile-time errors (illustrative; see comments below)
- Cannot create arrays of parameterized types:
// List<String>[] arr = new List<String>[10]; // error: generic array creation
- Cannot use instanceof with parameterized types:
// if (list instanceof ArrayList<String>) { } // error: illegal generic type for instanceof
- Erasure conflicts prevent overloading:
// void m(List<String> x) { }
// void m(List<Integer> x) { } // error: name clash after erasure
*/
public class _01_Theory {

    public static void main(String[] args) throws Exception {
        System.out.println("=== Type Erasure: what the JVM actually sees ===");
        demoTypeErasure();

        System.out.println();
        System.out.println("=== Non-reifiable types at runtime ===");
        demoNonReifiable();

        System.out.println();
        System.out.println("=== Heap pollution via raw types (erasure side-effect) ===");
        demoHeapPollution();

        System.out.println();
        System.out.println("=== Bridge methods generated by the compiler ===");
        demoBridgeMethods();
    }

    // Demonstrates erasure on classes and methods (unbounded, bounded, multiple bounds, and method type params).
    private static void demoTypeErasure() {
        System.out.println("-- GenericBox<T> (unbounded T erases to Object) --");
        printGenericVsErasedForMethods(GenericBox.class, "set", "get");

        System.out.println("-- NumberBox<T extends Number> (T erases to Number) --");
        printGenericVsErasedForMethods(NumberBox.class, "set", "get");

        System.out.println("-- MultiBound<T extends Number & Comparable<T>> (T erases to Number) --");
        printGenericVsErasedForMethods(MultiBound.class, "set");

        System.out.println("-- Method type parameter <U extends CharSequence> erases to CharSequence --");
        printGenericVsErasedForMethods(MethodTypeParamDemo.class, "echo");

        GenericBox<String> boxS = new GenericBox<>();
        GenericBox<Integer> boxI = new GenericBox<>();
        System.out.println("GenericBox<String>.class == GenericBox<Integer>.class -> " + (boxS.getClass() == boxI.getClass()));
    }

    // Shows that parameterized types lose their type arguments at runtime (non-reifiable).
    private static void demoNonReifiable() {
        List<String> a = new ArrayList<>();
        List<Integer> b = new ArrayList<>();
        System.out.println("ArrayList<String>.class == ArrayList<Integer>.class -> " + (a.getClass() == b.getClass()));

        // The following are illegal at compile time (examples):
        // List<String>[] arr = new List<String>[10];                // error: generic array creation
        // if (a instanceof ArrayList<String>) { }                   // error: illegal generic type for instanceof
    }

    // Raw types circumvent compile-time checks and can pollute the heap, leading to runtime exceptions.
    private static void demoHeapPollution() {
        List<String> strings = new ArrayList<>();
        strings.add("ok");
        unsafeAdd(strings, 123); // inserts Integer into a List<String> via raw type
        try {
            String first = strings.get(0); // ok
            System.out.println("First element: " + first);
            String second = strings.get(1); // ClassCastException due to compiler-inserted cast
            System.out.println("Second element: " + second);
        } catch (ClassCastException ex) {
            System.out.println("Caught ClassCastException when reading from List<String>: " + ex.getMessage());
        }
    }

    // Reflects on classes that cause the compiler to generate bridge methods.
    private static void demoBridgeMethods() {
        System.out.println("-- StringProcessor implements Processor<String> --");
        printDeclaredMethods(StringProcessor.class);

        System.out.println("-- Child extends Parent<String> and overrides get/set --");
        printDeclaredMethods(Child.class);

        System.out.println("-- StringList extends ArrayList<String> and overrides add --");
        printDeclaredMethods(StringList.class);

        System.out.println("-- PersonComparable implements Comparable<PersonComparable> --");
        printDeclaredMethods(PersonComparable.class);
    }

    private static void printGenericVsErasedForMethods(Class<?> cls, String... names) {
        List<String> nameFilter = Arrays.asList(names);
        System.out.println("Class: " + cls.getName());
        for (Method m : cls.getDeclaredMethods()) {
            if (!nameFilter.contains(m.getName())) continue;
            String genericParams = formatTypes(m.getGenericParameterTypes());
            String erasedParams = formatClasses(m.getParameterTypes());
            String genericRet = m.getGenericReturnType().getTypeName();
            String erasedRet = m.getReturnType().getTypeName();
            System.out.println(" - " + m.getName() + "(" + genericParams + ") -> " + genericRet);
            System.out.println("   erased to: " + m.getName() + "(" + erasedParams + ") -> " + erasedRet);
        }
    }

    private static void printDeclaredMethods(Class<?> cls) {
        System.out.println("Class: " + cls.getName());
        Method[] methods = cls.getDeclaredMethods();
        Arrays.sort(methods, Comparator
                .comparing(Method::getName)
                .thenComparingInt(m -> m.getParameterTypes().length)
                .thenComparing(m -> formatClasses(m.getParameterTypes())));
        for (Method m : methods) {
            String flags = (m.isBridge() ? " [bridge]" : "") + (m.isSynthetic() ? " [synthetic]" : "");
            System.out.println(" - " + m.getReturnType().getSimpleName() + " " + m.getName()
                    + "(" + formatSimpleClasses(m.getParameterTypes()) + ")" + flags);
        }
    }

    private static String formatClasses(Class<?>[] classes) {
        if (classes.length == 0) return "";
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < classes.length; i++) {
            if (i > 0) sb.append(", ");
            sb.append(classes[i].getTypeName());
        }
        return sb.toString();
    }

    private static String formatSimpleClasses(Class<?>[] classes) {
        if (classes.length == 0) return "";
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < classes.length; i++) {
            if (i > 0) sb.append(", ");
            sb.append(classes[i].getSimpleName());
        }
        return sb.toString();
    }

    private static String formatTypes(Type[] types) {
        if (types.length == 0) return "";
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < types.length; i++) {
            if (i > 0) sb.append(", ");
            sb.append(types[i].getTypeName());
        }
        return sb.toString();
    }

    // Intentionally unsafe to demonstrate heap pollution due to raw types.
    @SuppressWarnings({"rawtypes", "unchecked"})
    private static void unsafeAdd(List list, Object value) {
        list.add(value); // unchecked insertion
    }

    // === Sample types to illustrate erasure and bridges ===

    // Unbounded type parameter: T erases to Object.
    static class GenericBox<T> {
        private T value;
        public void set(T value) { this.value = value; } // erases to set(Object)
        public T get() { return value; }                 // erases to Object get()
    }

    // Bounded type parameter: T erases to Number.
    static class NumberBox<T extends Number> {
        private T value;
        public void set(T value) { this.value = value; } // erases to set(Number)
        public T get() { return value; }                 // erases to Number get()
    }

    // Multiple bounds: erases to the first bound (Number).
    static class MultiBound<T extends Number & Comparable<T>> {
        public void set(T value) { /* no-op */ }         // erases to set(Number)
    }

    // Method type parameter: U erases to CharSequence.
    static class MethodTypeParamDemo {
        public <U extends CharSequence> U echo(U u) { return u; } // erases to CharSequence echo(CharSequence)
    }

    // Generic interface to illustrate bridge methods on implementation.
    interface Processor<T> {
        T process(T t);
    }

    // Implements Processor<String> with a String-specific method. Bridge added: Object process(Object).
    static class StringProcessor implements Processor<String> {
        @Override
        public String process(String t) {
            return t == null ? null : t.trim().toUpperCase();
        }
    }

    // Generic parent; at runtime its methods use Object.
    static class Parent<T> {
        private T value;
        public void set(T value) { this.value = value; } // erases to set(Object)
        public T get() { return value; }                 // erases to Object get()
    }

    // Binds T to String and overrides; compiler emits bridges for set(Object) and get()Object.
    static class Child extends Parent<String> {
        @Override
        public void set(String value) { super.set(value); }
        @Override
        public String get() { return super.get(); }
    }

    // Extends parameterized type and overrides add(String); compiler emits add(Object) bridge.
    static class StringList extends ArrayList<String> {
        @Override
        public boolean add(String e) { return super.add(e); }
        private static final long serialVersionUID = 1L;
    }

    // Implements Comparable<PersonComparable>; compiler emits compareTo(Object) bridge.
    static class PersonComparable implements Comparable<PersonComparable> {
        private final String name;
        PersonComparable(String name) { this.name = name; }
        @Override
        public int compareTo(PersonComparable o) { return this.name.compareTo(o.name); }
    }
}